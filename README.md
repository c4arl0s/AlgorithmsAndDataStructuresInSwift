# Algorithms And Data Structures In Swift

1. [Introduction](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#1-introduction)
2. [The Big-O Notation](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#2-the-big-o-notation)
3. [Recursion](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#3-recursion)
4. [The Power of Algorithms](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#4-the-power-of-algorithms)
5. [Generics](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#5-generics)
6. [The Build-In Swift collection Types](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#6-the-build-in-swift-collection-types)
7. [Basic Sorting](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#7-basic-sorting)
8. [Advance Sorting](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#8-advance-sorting)


# 1. [Introduction](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#1-introduction)
 * [Why you should learn algorithms](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-why-you-should-learn-algorithms)
# 2. [The Big-O Notation](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#2-the-big-o-notation)
 * [Constant Time Complexity](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-constant-time-complexity)
 * [Linear Time Complexity](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-linear-time-complexity)
 * [Quadratic Time Complexity](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-quadratic-time-complexity)
 * [Hints of polinomial Time Complexity](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-hints-of-polinomial-time-complexity)
 * [Logarithmic Time](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-logarithmic-time)
 * [Summary](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-summary)
# 3. [Recursion](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#3-recursion-1)
 * [What is recursion?](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-what-is-recursion)
 * [How Does Recursion Work?](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-how-does-recursion-work)
# 4. [The Power of Algorithms](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#4-the-power-of-algorithms)
 * [Calculate Sum(n)](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-calculate-sumn)
 * [Pair Matching Challenge](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-pair-matching-challenge)
 * [Find the Equilibrium Index](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-find-the-equilibrium-index)
 * [Summary](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-summary-1)
# 5. [Generics](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#5-generics)
 * [Why Generics?](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-why-generics)
 * [Generic Types](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-generic-types)
 * [Generic Functions](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-generic-functions)
# 6. [The Build-In Swift collection Types](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#6-the-build-in-swift-collection-types)
 * [The Array](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-the-array)
 * [Accessing the Array](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-accessing-the-array)
 * [Modifying the Array](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-modifying-the-array)
 * [The Set](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-the-set)
 * [Accesing and Modifying the Set](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-accesing-and-modifying-the-set)
 * [Set Operations](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-set-operations)
 * [The Hashable Protocol](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-the-hashable-protocol)
 * [The Dictionary](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-the-dictionary)
 * [Creating Dictionaries](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-creating-dictionaries)
 * [Heterogeneous Dictionaries](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-heterogeneous-dictionaries)
 * [Accesing & Modifying the contents of a Dictionary](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-accesing--modifying-the-contents-of-a-dictionary)
# 7. [Basic Sorting](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#7-basic-sorting)
 * [Selection Sort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-selection-sort)
 * [Insertion Sort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-insertion-sort)
 * [Bubble Sort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-bubble-sort)
# 8. [Advance Sorting](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#8-advance-sorting)
 * [The merge sort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-the-merge-sort)
 * [QuickSort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#-quicksort)


# [Algorithms And Data Structures In Swift](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

# 1. [Introduction](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

This book it is just for fundamental knowledge about algorithms and data structures.

# Prerequisites.

This book is beginner-friendly. Prior programming experience may be helpful, but you need not have actually worked with the Swift itself.

To implement exercises in this book, you will need a Mac.
You will also need Xcode 9, at least.

We are going to use modern Swift 4 to implement the source code in this course.

Swift 4 added some useful enhancements and new features. All the samples are compatible with the latest Swift version. I am going to update the source code as changes in the language make it necessary.


# 	* [Why you should learn algorithms](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

Computer algorithms have been developed and refined over the last couple of decades. The study of algorithms is fundamental to any programmer who plans to develop a software system that is scalable and performant.

Once we got past the basic "Hello World" beginner applications, we begin to realize that complex applications require a different approach. The software which used to work nicely during our test becomes incredible slow and frequently crashes in real-world situations. The reason is that we have not prepared our system for real-life usage: While it ran without issues with small datasets during our tests, it fails miserably when the reality kicks in.

Algorithms are indispensable to building software that is capable of managing large amounts of data or solving complex problems efficiently.

Besides, you will probably come across algorithm and data structure related questions during job interviews.


# 2. [The Big-O Notation](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

The **Big-O notation** is a mathematical model used in computer science to describe the efficiency of algorithms as a functions of their input size.

The best way to understand the Big-O notation thoroughly (a fondo) is through code examples. Therefore, I am going to illustrate each concept using swift coding.

Here are the common orders of growth - or complexities - we are going to talk about this chapter:

**Constant Time**: Describes an algorithm that will always execute in the same amount of time, regardless of the input size.

**Linear Time**: Describes a algorithm whose performance will grow linearly and in direct proportion to the size of the input data set.

**Quadratic Time**: Represents an algorithm whose performance is directly proportional to the square of the size of the input data set. This behavior is typical with algorithms that involve nested iterations over the data set. Deeper nested iterations will result in O(N3) (cubic time), O(N4) quartic time and worse.

**Logarithmic Time**: Represents a highly efficient algorithm, used by the binary search technique for example.

We will cover the basics of Big-O. This knowledge is sufficient to understand the efficiency of the sorting algorithms presented in this course.

![Screen Shot 2020-05-30 at 10 54 31](https://user-images.githubusercontent.com/24994818/83332998-fab74c00-a263-11ea-8380-376c879f164b.png)


This graph visualizes the running times of some of the most popular sorting algorithms. As the input size increases, the performance differences become increasingly evident.
When the input count is small, all algorithms perform almost equality.

Actually, when testing with small datasets, we may even have the impression that the algorithms with a logarithmic complexity has the worst performance; however, as the size of the datasets grows, we will clearly see the differences.

# 	* [Constant Time Complexity](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

Constant Time describes an algorithm that will always require the same amount of time to execute, regardless of the input size.

Here is what we get if we visualize the running time of an algorithm that executes in constant time.

![Screen Shot 2020-05-31 at 11 16 44](https://user-images.githubusercontent.com/24994818/83361893-7f809380-a352-11ea-8e70-af8eaebbe253.png)

The input size does not affect the execution time. In other words, the execution time remains constant.

An algorithm which has a **constant time complexity will run for the same amount of time whether it operates on one or on several thousand or million entries**.

We will implement a utility class for measuring the performance. We will use this utility class to perform measurements in the current demo and several other upcoming project.

To illustrate the constant time complexity, we will create a function that performs a check on an array.

The second example relies o the hash map lookup. We are going to compare the times required to retrieve values based on their keys from Swift dictionaries from Swift dictionaries of various sizes. If implemented correctly, the hash map lookup should happen in constant time.

First, we will implement the benchmarking utility. The BenchTimer class has a single method called measureBlock(closure:).

```swift
import Foundation
import QuartzCore

public class BenchTimer {
    public static func measureBlock(closure:() -> Void) -> CFTimeInterval {
        let runCount = 10
        var executionTimes = Array<Double>(repeating: 0.0, count: runCount)
        for index in 0..<runCount {
            let startTime = CACurrentMediaTime()
            closure()
            let endTime = CACurrentMediaTime()
            let executionTime = endTime - startTime
            executionTimes[index] = executionTime
        }
        return (executionTimes.reduce(0, +)) / Double(runCount)
    }
}
```

Remember the ways you can declare an array] [in Array Types Chapter](https://github.com/c4arl0s/Swift#2-array-types)
Remember how to fill an array with a value in [Working with arrays](https://github.com/c4arl0s/Swift#3-working-with-arrays)

The **measured(closure:)** type method takes a closure argument. The measured code is executed times, and we store the individual run times in an array.

We rely on the **QuartzCore** framework's **CACurrent-MediaTime()** function to retrieve the current absolute time.

Unlike **NSDate** or **CFAbsoluteTimeGetCurrent()**, **CACurrentMediaTime()** is reliable since it is not subject to changes in the external time reference.

The measured block gets executed between querying the **startTime** and **endTime**; the run time is then The measured block gets executed between querying the startTime and endTime, the run time is then stored in the executionTimes array.

After ten iterations, we calculate the **average execution time**. The **reduce()** array function calls the closure sequentially on all the array elements, which in our case sums up all the items in the array.

Finally, we divide the result by the number of iterations, which gives us **the average execution time.**

Next, we write the code extension to format the time delivered by CFTimeInterval type

```swift
public extension CFTimeInterval {
    var formattedTime: String {
        return self >= 1000 ? String(Int(self)) + "s" : self >= 1 ? String(format: "%.3gs", self) : self >= 1e-3 ? String(format: "%.3gms", self * 1e3) : self >= 1e-6 ? String(format: "%.3gus", self * 1e6) : self < 1e-9 ? "0s" : String(format: "%.3gns", self * 1e9)
    }
}
```

Next, we implement a function, which takes an array and checks whether the first element is 0.

```swift
func startsWithZero(array: [Int]) -> Bool {
    guard array.count != 0 else { return false }
    return array.first == 0 ? true : false
}
```

This simple executes in constant time, that is, the run time should be the same regardless of the size of the input array.

Let's prove our theory. We will invoke the startsWithZero() function with three arrays. The first array has only thee elements, the second one has 10,000 entries and the third array is huge, with 1,000,000 items.

```swift
import Foundation
import QuartzCore

public class BenchTimer {
    public static func measureBlock(closure:() -> Void) -> CFTimeInterval {
        let runCount = 10
        var executionTimes = Array<Double>(repeating: 0.0, count: runCount)
        for index in 0..<runCount {
            let startTime = CACurrentMediaTime()
            closure()
            let endTime = CACurrentMediaTime()
            let executionTime = endTime - startTime
            executionTimes[index] = executionTime
        }
        return (executionTimes.reduce(0, +)) / Double(runCount)
    }
}
```

- Create a method to verify if the first element of an array is Zero

```swift
func startsWithZero(array: [Int]) -> Bool {
    guard array.count != 0 else { return false }
    return array.first == 0 ? true : false
}
```

- Test a very small array

```swift
var verySmallArray = [1,0,0]
var executionTime = BenchTimer.measureBlock {
    _ = startsWithZero(array: verySmallArray)
}

print("Average startsWithZero() execution time for array with \(verySmallArray.count) elements is \(executionTime.formattedTime)")
``` 

- Test a medium Array

```swift
var mediumArray = Array<Int>(repeating: 0, count: 1000)
executionTime = BenchTimer.measureBlock {
    _ = startsWithZero(array: mediumArray)
}

print("Average startsWithZero() execution time for array with \(mediumArray.count) elements is \(executionTime.formattedTime)")
```

- Test a huge array

```swift
var hugeArray = Array<Int>(repeating: 0, count: 1000000)
executionTime = BenchTimer.measureBlock {
    _ = startsWithZero(array: hugeArray)
}

print("Average startsWithZero() execution time for array with \(hugeArray.count) elements is \(executionTime.formattedTime)")
```

- execute and see

```console
Average startsWithZero() execution time for array with 3 elements is 2.69ms
Average startsWithZero() execution time for array with 1000 elements is 111us
Average startsWithZero() execution time for array with 1000000 elements is 102us
```

Another Algorithm which runs in constant time is the hash-map lookup.
We will use the **generateDictionary(size:)** helper function method to create custom-sized dictionaries.

```swift
let smallDictionary = ["one": 1, "two": 2, "three": 3]
var executionTime = BenchTimer.measureBlock {
    _ = smallDictionary["two"]
}
print("Average lookup time in a dictionary with \(smallDictionary.count) elments: \(executionTime.formattedTime)")
```

```console
Average lookup time in a dictionary with 3 elments: 133us
```

- Create a method to generate dictionaries

```swift
func generatesDictionaries(size: Int) -> Dictionary<String,Int> {
    var result = Dictionary<String,Int>()
    guard  size > 0 else { return result }
    for index in 0..<size {
        let key = String(index)
        result[key] = index
    }
    return result
}
```

- Use it to medium sizes

```swift
let mediumDictionary = generatesDictionaries(size: 500)
executionTime = BenchTimer.measureBlock {
    _ = mediumDictionary["324"]
}
print("Average lookup time in a dictionary with \(mediumDictionary.count) elements: \(executionTime.formattedTime)")
```

```console
Average lookup time in a dictionary with 500 elements: 82.8us
```

- Use it to huge sizes

```swift
let hugeDictionary = generatesDictionaries(size: 100000)
executionTime = BenchTimer.measureBlock {
    _ = hugeDictionary["55555"]
}
print("Average lookup time in a dictionary with \(hugeDictionary.count) elements: \(executionTime.formattedTime)")
```

```console
Average lookup time in a dictionary with 100000 elements: 90.7us
```

I present here all outputs:

```console
Average lookup time in a dictionary with 3 elments: 133us
Average lookup time in a dictionary with 500 elements: 82.8us
Average lookup time in a dictionary with 100000 elements: 90.7us
```

As you will see after the demo, the time it takes to find an element does not depend on the size of the dictionary.

Constant time algorithms are great because they are not affected by any of the input parameters. However, it is not always possible to come up with a solution which runs in constant time.


# 	* [Linear Time Complexity](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

Linear Time describes an algorithm whose performance will grow linearly and in direct proportion to size of the input dataset

This graph represents the running time of an algorithm which executes in linear time.

![Screen Shot 2020-06-02 at 10 17 10](https://user-images.githubusercontent.com/24994818/83537507-3ea38e80-a4ba-11ea-9aec-eecd591f60a8.png)

There is a 1 to 1 correlation between input size and execution time.

The run time of an algorithm with linear time complexity will increase at the same time as the input dataset grows. 

For example, if one thousand entries took one second to process, then 10 thousand would require ten time as much, that is, 10 seconds, 100,000 entries would be processed in 100 seconds and so on. As input dataset grows, so will our algorithm processing time increase, too. That is why it is called linear time.

Next, we will implement some examples that will execute in linear time.

Firs, I am going to show you a function which sums up the elements of an array.

The next function we implement returns the number of odd and even integers from an array. Both functions will iterate through the entire array. 

Therefore the computation time is directly related to the size of the array. We have linear complexity in both cases. For performance measurements, we will rely on the **BenchTimer** we built in the [previous chapter]()

To illustrate the linear time complexity we will need arrays of different sizes.

So let's first implement a function which generates custom-sized arrays with random content.


```swift
// generate random array of given size
func generateRandomArray(size: Int, maxValue: UInt32) -> [Int] {
    guard size > 0 else { return [Int]() }
    var result = [Int](repeating: 0, count: size)
    for index in 0..<size {
        result[index] = Int.random(in: 0...Int(maxValue))
    }
    return result
}
```

The **generateRandomArray(size: maxValue:)** function takes two arguments: first gives the size of the array, and maxValue which determinates the maximum allowed value for the elements.

Next, we create a function which sums up the elements of the input array

```swift
func sum(array: [Int]) -> Int {
    var result = 0
    for index in 0..<array.count {
        result += array[index]
    }
    return result
}
```

We could use reduce() array function to calculate the sum, but implementing a custom solution makes it obvious that we iterate over the entire array.

We are going to test the **sum(array:)** function with three arrays of different sizes. The first array has 100 items, the next has 1000 and the last one has 10000 elements.

```swift
let array100 = generateRandomArray(size: 100, maxValue: UInt32.max) 
var executionTime = BenchTimer.measureBlock {
	_ = sum(array: array100)
}
print("Average sum() execution time for \(array100.count) elements: \(executionTime.formattedTime)")
```

```console
Average sum() execution time for 100 elements: 3.33ms
```


```swift
let array1000 = generateRandomArray(size: 1000, maxValue: UInt32.max)
executionTime = BenchTimer.measuredBlock {
	_ = sum(array: array1000)
}
print("Average sum() execution time for \(array1000.count) elements: \(executionTime.formattedTime)")
````

```console
Average sum() execution time for 1000 elements: 71.4ms
```

```swift
let array10000 = generateRandomArray(size: 10000, maxValue: UInt32.max)
executionTime = BenchTimer.measureBlock {
    _ = sum(array: array10000)
}
print("Average sum() execution time for \(array10000.count) elements: \(executionTime.formattedTime)")
```

```console
Average sum() execution time for 10000 elements: 726ms
```

After executing our test, the performance measurement values displayed in the console prove that the execution time is linear.

Here I present the three outputs:

```console
Average sum() execution time for 100 elements: 3.33ms
Average sum() execution time for 1000 elements: 71.4ms
Average sum() execution time for 10000 elements: 726ms
```

The **sum(array:)** function iterates through all the elements of the array. Thus, it is normal that the execution time increases proportionally with the size of the array.

Here is another function which needs to iterate through all the elements of the input list.

```swift
func countOddAndEven(array: [Int]) -> (event: UInt, odd: UInt) {
    var even: UInt = 0
    var odd: UInt = 0
    
    for element in array {
        if element % 2 == 0 {
            even += 1
        } else {
            odd += 1
        }
    }
    return (even, odd)
}
```

- Test method

```swift
let numberOfOddAndEven = countOddAndEven(array: [1, 2, 3, 4, 5])
print("number Of Odd And Even are \(numberOfOddAndEven)")
```

```console
number Of Odd And Even are (event: 2, odd: 3)
```

The **countOddEven(array:)** function checks each item to find out whether it is odd or even.

Our test confirm that **countOddEven(array:)** is indeed a function which runs in linear time - the execution time increases at the same rate as the input dataset grows.

# 	* [Quadratic Time Complexity](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

Quadratic Time represents an algorithm whose performance is directly proportional to the square of the size of the input dataset.

As you can see in this chart, the runtime increases sharply, faster that the input sizes.

![Screen Shot 2020-06-03 at 18 00 27](https://user-images.githubusercontent.com/24994818/83697260-2455d780-a5c4-11ea-9a90-b0a0211998a4.png)

The runtime of an algorithm with quadratic time complexity will go up as a square of the input dataset size.

**Quadratic, cubic and quartic time complexities are a result of nested operations on a dataset**. You should try to avoid them whenever possible, due the negative impact on the overall performance.

Let's say your quadratic-time algorithm processes 100 entries in 100 milliseconds.

For 2000 entries the algorithm would run for 40 seconds. And 4000 entries would be processed in slightly more than 26 minutes!

![Screen Shot 2020-06-03 at 18 05 11](https://user-images.githubusercontent.com/24994818/83697507-ce356400-a5c4-11ea-8e93-95a91a58f73f.png)

The runtime grows even more sharply with the input size in the case of cubic or quadratic time complexity.

In the following demo, we are going to build a function that creates multiplication tables. The function will use two nested loops; because of the nested iterations, this algorithm has a quadratic time complexity.

Now let's switch to Xcode.

First, we implement a useful addition for our benchmarking utility:

Carlos, remember that this implentation was not available for constant an linear time complexity chapters, so apply them all.

```swift
import Foundation
import QuartzCore

public extension CFTimeInterval {
    var formattedTime: String {
        return self >= 1000 ? String(Int(self)) + "s" : self >= 1 ? String(format: "%.3gs", self) : self >= 1e-3 ? String(format: "%.3gms", self * 1e3) : self >= 1e-6 ? String(format: "%.3gus", self * 1e6) : self < 1e-9 ? "0s" : String(format: "%.3gns", self * 1e9)
    }
}
```

We add **formattedTime** property to the **CFTimeInterval** type. This property provides a concise string representation of the time interval value which also includes the right unit of time, which ranges from nanoseconds to seconds.

Next, we will implement a function to demonstrate the quadratic time complexity:

```swift
func multiplicationTable(size: Int) -> [Int] {
    var table = [Int]()
    let array = [Int](1...size)
    for outsideIndex in 0..<array.count {
        for insideIndex in 0..<array.count {
            let value = array[outsideIndex]*array[insideIndex]
            table.append(value)
        }
    }
    return table
}
```

The **multiplicationTable(size:)** function takes an integer argument which gives the size of the array which holds positive integers in the range 1..size. The function returns the result of multiplying each element in the array with every other value.

We use two loops to computes the result: the outer loop iterates through the indices of the array. The internal loop takes the value found at the outer index and multiplies it with every item from the same array. The output is a multiplication table. Let's check out what we get for the input value 10.

Now let's analyze how the two nested loops influence the processing time.

For a two-element array, the outer loop iterates two times, and the internal loop also two times every outer iteration. This gives us four iterations in total.

For a three-element array, the total iteration count is 3 times 3, that is, 9. For ten elements the function will loop 100 times.

The number or iterations goes up as a square of the input data size.

Let's run some performance tests to prove that our function runs at quadratic time complexity. We call the **multiplicationTable(size:)** function with arrays of different sizes, and we will display the run times in the console.

```swift
let sizes = [10, 20, 30]

for index in 0..<sizes.count {
    let size = sizes[index]
    let executionTime = BenchTimer.measureBlock {
        _ = multiplicationTable(size: size)
    }
    print("Average multiplicationTable() execution time for \(size) elements is \(executionTime.formattedTime)")
}
```

output:

```swift
Average multiplicationTable() execution time for 10 elements is 123ms
Average multiplicationTable() execution time for 20 elements is 764ms
Average multiplicationTable() execution time for 30 elements is 2.14s
```

After executing the demo, we can see the quadratic jumps in execution time.

---
**Note**
It is worth mentioning that especially for smaller input, the measurements might not always reflect the quadratic time complexity because of under the hood compiler and hardware optimizations.
---


# 	* [Hints of polinomial Time Complexity](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

Nested loops within a method of function should always be a warning sign, and you should avoid them at all costs.

Whenever you encounter two or more loops that resemble **Russian nesting dolls**, ask yourself whether the nested iterations are really required to solve that particular problem.

First, document the questionable code using dedicated comments (!!! or XXX) - or even better, add a **warning** if supported by the given compiler. Then implement unit tests to highlight the performance issue caused by the nested loops.

Finally, try to solve the problem by replacing the nested iterations with a more efficient algorithm.

Polynomial time complexity is usually the result of rushed coding, produced by developers who lack time or expertise, or maybe both.

More often than not, you will find a better solution.

In the chapter called "The power of Algorithms" we will see examples of replacing inefficient approaches with solutions that bring huge performance gains.

There may be cases when there really is no better way to solve that problem, and you can't get rid of the nested loops. Then document the affected method thoroughly and describe why it works that way. Also, describe the performance issues it may cause with large datasets.

# 	* [Logarithmic Time](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

Logarithmic Time represents and extremely efficient algorithm, used by advance algorithms like the binary search engine.

Logarithmic time means that time goes up linearly while the input data size goes up exponentially.

![Screen Shot 2020-06-06 at 17 36 43](https://user-images.githubusercontent.com/24994818/83955766-519cc280-a81c-11ea-8491-389e97d4a71d.png)

For example, if it takes 1 milisecond to compute 10 elements, it will take 2 miliseconds to compute 100 elements, 3 miliseconds to compute 1000 elements, and so on.

**Binary search**, quick sort and divide and conquer type of algorithms run usually in logarithmic time.

First, let's take a closer look at the logarithm.

In mathematics, the logarithm is the inverse operation to exponentiation.

The logarithm of x to base b:

logb(x) = y

is the unique real number y such that:

b^y = x

For example, log10(1000) = 3 as 10^3 = 1000

And log4(16) = 2, because 4^2 = 16

In other words.

>The logarithm of a number is the exponent to which another fixed numbers, the base, must be raised to produced that number.

logb(x) = y
b^y = x

In computer science, when measuring the performance of algorithms, the base of the logarithm is not specified, because the result only changes by a constant factor when another base is used. A constant factor is usually disregarded in the analysis of algorithms.

# 	* [Summary](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

We dedicated this entire chapter to the Big-O notation. 

Understanding time complexity paves the road to working with algorithms.

We have talked about constant time complexity - where the execution time is constant and does not depend of he input size.

**Checking the first element of an array or retrieving an item from a dictionary are good examples for the constant time complexity**.

Linear time complexity describes an algorithm whose runtime grows in direct proportion to the size of the input. For example, **enumerating though the elements of an array words in linear time**

The execution times of quadratic time algorithms go up as a square of the input dataset size. **Quadratic time complexity is produced by a loop nested into another loop, was we have seen in our multiplication table example**.

Try to avoid polynomial time complexity- like quadratic, quartic or cubic- as it can become a huge performance bottleneck.

Logarithmic time describes complex algorithms like the quicksort and shows its benefits when working with large data sets.

# 3. [Recursion](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

In Programming, repetition can be described using loops, such as the for-loop or the while loop. Another way is to use recursion.

We encounter recursion frequently while studying algorithms and data structures

Thus, It is important to understand what recursion is.

I am going to show you how recursion works through live coding examples.

Recursion is a useful technique, yet it does not come without pitfalls (problemas, trampas). We will finish this chapter by demonstrating how to avoid common issues when using recursion in Swift Projects.

# 	* [What is recursion?](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

By definition, recursion is a way to solve a reoccurring problem by repeatedly solving similar subproblems.

In programming, we can have recursive functions. A function is recursive if it calls itself. The call can happen directly like in this case:

```swift
func r() {
	//...
	r()
	//...
}
```

Or indirectly, if the function calls another function, which in turn invokes the first one:

```swift
func r() {
	//...
	g()
	//...
}

func g() {
	//...
	r()
	//...
}
```

We will often encounter recursive data structures, too. A **data structure** is recursive if you can describe it in terms of itself.

A **linked list** can be described as a **list node** followed by a **linked list**.
![Screen Shot 2020-06-08 at 19 16 55](https://user-images.githubusercontent.com/24994818/84092359-babb3c00-a9bc-11ea-8c39-d4c473e2f1ad.png)

Here is a simple Node class:

```swift
class Node {
    var value: String
    var next: Node?
    
    init(value: String) {
        self.value = value
    }
}
```

Each node can link to the next node through the next property.

![Screen Shot 2020-06-08 at 19 26 23](https://user-images.githubusercontent.com/24994818/84092753-f571a400-a9bd-11ea-8c28-20f1f56323bf.png)

The Node also holds a value of type string. I provide an initializer which sets the value property. 

Now that we have our Node type, let's build a linked list


- Create the nodes

```swift
let node1 = Node(value: "value of nodo1")
let node2 = Node(value: "value of nodo2")
let node3 = Node(value: "value of nodo3")
```
- Set the next property of each node.

```swift
node1.next = node2
node2.next = node3
node3.next = nil
```

First, I create each node using a value that matches its name. Then, I assign the next property of each node to form a singly linked list. I end the linked list after three nodes by setting the next property to nil.

Let's implement a function that traverses the linked list and prints the value in each node.

```swift
func parseNodes(from node: Node?) {
    guard let validNode = node else { return }
    print(validNode.value)
    parseNodes(from: validNode.next)
}
```

The parseNodes(from:) function takes an argument of type Node. This is the node where we start the list traversal.

If the node is nil, we exit the function. Else, we print the value of the given  node.

The function calls the parseNodes(from:) method recursively by passing in the next node.

Finally, we call the parseNodes(from:) function with the first node as input parameter.

```swift
parseNodes(from: node1)
```

```console
value of nodo1
value of nodo2
value of nodo3
```

Now from node2

```swift
parseNodes(from: node2)
```

```console
value of nodo2
value of nodo3
```

Now from node3

```swift
parseNodes(from: node3)
```

```console
value of nodo3
```

If we run the demo, it prints the expected values. Since the data structure is **recursive**, we can use recursion to iterate through it.

> Recursion will not necessarily produce faster or more efficient code. But it usually provides an elegant alternative to iterate approaches and requires fewer lines of code.

# 	* [How Does Recursion Work?](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)

So far, we have seen some examples of recursive functions and data structures. Now, let's check out how recursion works.

We are going to calculate the factorial of a positive integer n. This is a problem that can be solved using recursion, since the factorial is defined as the product of the integers from 1 to n.

n! = 1 x 2 x 3 ... x n

So, here's the swift factorial function that calculates the factorial of a positive integer:

```swift
func factorial(number: UInt64) -> UInt64 {
   return number < 2 ? 1 : number * factorial(number: number-1)
}

let factorialNumber = factorial(number: 20)
print(factorialNumber)
```

The function takes an unsigned integer as argument. If the input parameter is 1 or 0, the function returns 1. Otherwise, the function returns the product of the input and the result of calling the function with and argument that is smaller by one.

The recursive calls continue until the function gets called with a value that is smaller than 2.

To understand how recursion works, here is a graphical representation of what is going on when calculating factorial of 3.

![Screen Shot 2020-06-10 at 17 14 54](https://user-images.githubusercontent.com/24994818/84324253-fa5d6180-ab3d-11ea-83b9-ae63ca236893.png)

Whenever a nested call happens, the execution of the former call is suspender and its stat is stored. A snapshot of its content, that is, its code, input parameters and local variables is persisted.

All this information is stored in a structure known as "call stack" or "execution stack" The call stack is a stack structure that keeps track of the point where control should be returned after the subroutine finishes its execution. When the nested call is finished executing, its context is destroyed, and the control is returned to the caller.

Eventually, we get back to the very first function call. All the nested contexts are destroyed by then and the result is returned to the caller.

# 4. [The Power of Algorithms](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Calculate Sum(n)](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Pair Matching Challenge](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Find the Equilibrium Index](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Summary](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 5. [Generics](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Why Generics?](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Generic Types](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Generic Functions](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 6. [The Build-In Swift collection Types](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [The Array](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Accessing the Array](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Modifying the Array](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [The Set](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Accesing and Modifying the Set](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Set Operations](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [The Hashable Protocol](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [The Dictionary](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Creating Dictionaries](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Heterogeneous Dictionaries](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Accesing & Modifying the contents of a Dictionary](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 7. [Basic Sorting](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Selection Sort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Insertion Sort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [Bubble Sort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 8. [Advance Sorting]()
# 	* [The merge sort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
# 	* [QuickSort](https://github.com/c4arl0s/AlgorithmsAndDataStructuresInSwift#algorithms-and-data-structures-in-swift)
 
